Module *m_vendor*
******************

Documentation for the modules-m_vendor module in */std/modules/m_vendor.c*.

Module Information
==================

m_vendor is used to create vendor objects that buy and sell stuff
they work as traditional shopkeepers and also bartenders.
See: /domains/std/shopkeeper.c
See:  for possible interactions and notes about generic items.

Functions
=========
.. c:function:: float set_cost_multiplicator(float m)



.. c:function:: void set_clear_numbers(int cn)

Sets numbers to be clear fractions (1) in the vendor list,
or lists of denominations (0) - default.


.. c:function:: float selling_cost(float cost)

multiply the objects value with cost_mult to get the cost for selling


.. c:function:: float buying_cost(float cost)

override if you want a different way to determine cost


.. c:function:: varargs void add_sell(string file, int amt, mixed *setup_args)

enables you to add items to the vendors stored_item's mapping


.. c:function:: void set_sell(mapping items)

with a mapping you can set many items into the vendor's to sell list
Two formats are support:
  set_sell((["^std/consumable/apple":-1, "^std/weapon/sword":3, "^std/ale":-1, ]));
and another format supporting custom setup() arguments.
  set_sell((["^std/generic_item": ({-1,({"test object",15})}),"^std/weapon/sword":3]));
First argument is still count (or -1 for infinite), seconds argument is args for setup().


.. c:function:: void add_sell_object(object ob)

adds a unique item to the vendor's stored_items mapping


.. c:function:: void set_for_sale(mixed x)

Set the *of object names which this living object is willing to sell.
set_for_sale(1) means everything is for sale.  set_for_sale(0) means nothing
is.  If a function is passed it will get the object to sell as argument.
If a single string is returned it will be used as error message.


.. c:function:: void set_will_buy(mixed x)

Set the *of object names which this living object is willing to buy.
set_will_buy(1) means it will buy anything.  set_will_buy(0) means it wont
by anything.  If a function is passed it will get the object to buy as
argument. If a single string is returned it will be used as error message.


.. c:function:: mixed set_currency_type(string type)

Sets the type of currency the vendor will buy/sell in


.. c:function:: mixed query_currency_type()

Queries the type of currency the vendor will buy/sell in


.. c:function:: mixed query_items(string item, int flag)

gets called from the verb ask and the rule ask obj about str
The player commands buy and list use it too.
This function shows the players what items the shopkeeper has.
If flag is set the it will show the long() too


.. c:function:: void sell_stored_objects(string item, int number, int amount)

Gets called from the buy verb with the string from obj rule.
This is the way the players can buy objects from the shopkeeper
that he has stored away.


.. c:function:: void set_unique_inventory(string str)

void set_unique_inventory(string str)
This function determines if the vendor should hold onto what he
buys instead of desting it and replacing it with an original.  For
Example without unique set if you sell a sword to the vendor, no
matter what the condition is, it will be dested and replaced with
a new one.  Some muds would prefer the old way of what you sell is
what you buy.  The unique inventory is set by sending the room
where the inventory is kept.
ex: set_unique_inventory("/domains/std/room/storage");
NOTE: only armour, weaps, vehicles are uniqued
Unless the object has a is_unique() { return 1; } function in it
See set_all_unique to unique everything


.. c:function:: void set_all_unique(int i)

Sets ALL objects to be uniqued.  Only works when set_unique_inventory()
is used.


.. c:function:: int check_uniqueness(object ob)

This fuction test if an object should be destroyed or saved when bought,
depending on destroyable(), set_all_unique() and is_unique().



*File generated by Lima 1.1a4 reStructured Text daemon.*
